<!DOCTYPE HTML>
<html lang="en-us" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using nimibook -->
        <meta charset="UTF-8">
        <title>Common datatypes - SciNim Getting Started</title>

        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Tutorials for libraries in SciNim ecosystems">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
        <link rel="stylesheet" href="../assets/css/variables.css">
        <link rel="stylesheet" href="../assets/css/general.css">
        <link rel="stylesheet" href="../assets/css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../assets/FontAwesome/css/font-awesome.min.css">

        <!-- Highlight.js Stylesheets - I could use nimib native highlight but let's keep it for styling... -->
        <link rel="stylesheet" href="../assets/css/highlight.css">
        <link rel="stylesheet" href="../assets/css/tomorrow-night.css">
        <link rel="stylesheet" href="../assets/css/ayu-highlight.css">

        <!-- Custom theme stylesheets - why the "../"? -->


        

            <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

        
        <!-- plausible analytics (new in nimibook) -->
        <script defer data-domain="scinim.github.io/getting-started" src="https://plausible.io/js/plausible.js"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "..//assets";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                                <ol class="chapter">
                <li class="chapter-item expanded ">
                  <a href="../index.html" tabindex="0">
                    <strong aria-hidden="true">1.</strong> Introduction
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../overview/index.html" tabindex="0">
                    <strong aria-hidden="true">2.</strong> Ecosystem overview
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../basics/index.html" tabindex="0">
                    <strong aria-hidden="true">3.</strong> Basic topics
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../basics/common_datatypes.html" class="active" tabindex="0">
                    <strong aria-hidden="true">3.1.</strong> Common datatypes
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../basics/data_wrangling.html" tabindex="0">
                    <strong aria-hidden="true">3.2.</strong> Data wrangling with dataframes
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../basics/basic_plotting.html" tabindex="0">
                    <strong aria-hidden="true">3.3.</strong> Plotting
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../basics/units_basics.html" tabindex="0">
                    <strong aria-hidden="true">3.4.</strong> Units
                  </a></li>
                  </ol>
                  </li>
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/index.html" tabindex="0">
                    <strong aria-hidden="true">4.</strong> Numerical methods
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/curve_fitting.html" tabindex="0">
                    <strong aria-hidden="true">4.1.</strong> Curve fitting
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/integration1d.html" tabindex="0">
                    <strong aria-hidden="true">4.2.</strong> Integration (1D)
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/ode.html" tabindex="0">
                    <strong aria-hidden="true">4.3.</strong> ODEs
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/optimization.html" tabindex="0">
                    <strong aria-hidden="true">4.4.</strong> Optimization
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/interpolation.html" tabindex="0">
                    <strong aria-hidden="true">4.5.</strong> Interpolation
                  </a></li>
                  </ol>
                  </li>
                <li class="chapter-item expanded ">
                  <a href="../data_viz/index.html" tabindex="0">
                    <strong aria-hidden="true">5.</strong> Data visualization
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../data_viz/plotting_data.html" tabindex="0">
                    <strong aria-hidden="true">5.1.</strong> Plotting data
                  </a></li>
                  </ol>
                  </li>
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/index.html" tabindex="0">
                    <strong aria-hidden="true">6.</strong> Interfacing with other language
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/nim_with_py.html" tabindex="0">
                    <strong aria-hidden="true">6.1.</strong> Nimpy - The Nim Python bridge
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/julia/basics.html" tabindex="0">
                    <strong aria-hidden="true">6.2.</strong> Nimjl - The Nim Julia bridge
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/julia/nimjl_conversions.html" tabindex="0">
                    <strong aria-hidden="true">6.2.1.</strong> Advanced types
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/julia/nimjl_arrays.html" tabindex="0">
                    <strong aria-hidden="true">6.2.2.</strong> Julia Arrays from Nim
                  </a></li>
                  </ol>
                  </li>
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/nim_with_R.html" tabindex="0">
                    <strong aria-hidden="true">6.3.</strong> Interfacing with R
                  </a></li>
                </ol>
<!-- I could use also an unescaped context value -->
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">SciNim Getting Started</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/SciNim/getting-started" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1>Basic data types encountered in scientific computing in Nim</h1>
<p>Most operations using scientific computing packages in Nim will require one of three
different data types:</p>
<ul>
<li><code>seq[T]</code></li>
<li><code>Tensor[T]</code></li>
<li><code>DataFrame</code></li>
</ul>
<p>to store multiple scalar values (typically <code>float</code> values).</p>
<p><code>T</code> is the typical letter used to indicate generics in Nim. This means the explicit type
will be determined by the argument / desired type to store in the container, for example
<code>seq[int], Tensor[float]</code> etc.</p>
<p>There are of course further types used in many packages, but these three are typically
used to actually store data. Other objects may wrap any of these for different purposes,
e.g. <a href="https://github.com/hugogranstrom/numericalnim">numericalnim</a> contains different
helper objects for integration or interpolation.</p>
<p>We will now look at each of these three data types individually and discuss how to create
variables of each type and what typical use cases are.</p>
<h2><code>seq[T]</code> - homogeneous, dynamically resizable sequence</h2>
<p><code>seq[T]</code> is the default, dynamically resizable container from Nim's standard library. As the
single generic argument <code>T</code> implies it is homogeneous, which means one sequence stores
elements of a single data type.</p>
<p>Their implementation is essentially a pointer to a memory array, the length of the allocated
memory as well as the length of elements actually stored in it. We will discuss this further
down in section &quot;Length and capacity of a sequence&quot;.</p>
<p>In addition to <code>seq[T]</code> Nim also supports fixed size arrays. While these can be very useful
they won't be discussed here.</p>
<p>The standard library provides different ways to construct a sequence. Let's look at the
default two constructors first:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> x = @[<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>]
<span class="hljs-keyword">echo</span> x
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Length: &quot;</span>, len(x)</code></pre><pre class="nb-output">@[0.0, 1.0, 2.0, 3.0]
Length: 4</pre>
                        <p>The first constructor explicitly converts a number of elements into a sequence with
4 elements. The length of the sequence can be accessed using <code>len</code>.</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> x = newSeq[<span class="hljs-built_in">float</span>]()
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Length: &quot;</span>, x.len</code></pre><pre class="nb-output">Length: 0</pre>
                        <p>The second way to construct a sequence uses the <code>newSeq</code> procedure. It receives the
generic type that should be housed in the sequence and as an argument the number of
initial elements (the default being 0).</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> x = newSeq[<span class="hljs-built_in">float</span>](<span class="hljs-number">4</span>)
<span class="hljs-keyword">echo</span> x
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Length: &quot;</span>, x.len</code></pre><pre class="nb-output">@[0.0, 0.0, 0.0, 0.0]
Length: 4</pre>
                        <p><code>x</code> then uses the <code>newSeq</code> constructor to directly construct a sequence of floats of
length 4. All elements in the sequence are initialized to zero!</p>
<p>From here we can modify any created sequence, remove elements or add new elements as
long as the variable is declared as a <code>var</code> (instead of <code>let</code>).</p>
<h3>Access</h3>
<p>Elements in the sequence are accessed using bracket <code>[]</code> access:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> x = @[<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>]
<span class="hljs-keyword">echo</span> x[<span class="hljs-number">2</span>]</code></pre><pre class="nb-output">2.0</pre>
                        <h3>Mutation</h3>
<p>Basic mutation of elements in the sequence is done using <code>[]=</code> (in Nim terms), which is simply
bracket access and an assignment:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> x = newSeq[<span class="hljs-built_in">float</span>](<span class="hljs-number">4</span>)
x[<span class="hljs-number">0</span>] = <span class="hljs-number">5.0</span>
<span class="hljs-keyword">echo</span> x</code></pre><pre class="nb-output">@[5.0, 0.0, 0.0, 0.0]</pre>
                        <p>New elements are added using <code>add</code> as is typical in Nim:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> x = newSeq[<span class="hljs-built_in">float</span>]()
x.add <span class="hljs-number">10.0</span>
<span class="hljs-keyword">echo</span> x
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Length: &quot;</span>, x.len</code></pre><pre class="nb-output">@[10.0]
Length: 1</pre>
                        <p>So <code>y1</code> now contains 1 element instead of 0.</p>
<p>Deleting elements is also supported, via <code>delete</code> or <code>del</code>. Both procedures take the index
to be removed. <code>delete</code> keeps the order of the sequence intact, whereas <code>del</code> simply overwrites
the given index with the last element of the sequence and reduces the length by one. Compare:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> x1 = @[<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>]
<span class="hljs-keyword">var</span> x2 = x1
<span class="hljs-keyword">var</span> x3 = x1
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Starting from: &quot;</span>, x1
x2.delete(<span class="hljs-number">1</span>)
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Remove index 1 using `delete`: &quot;</span>, x2
x3.del(<span class="hljs-number">1</span>)
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Remove index 1 using `del`: &quot;</span>, x3</code></pre><pre class="nb-output">Starting from: @[0.0, 1.0, 2.0, 3.0]
Remove index 1 using `delete`: @[0.0, 2.0, 3.0]
Remove index 1 using `del`: @[0.0, 3.0, 2.0]</pre>
                        <p>See how the order of <code>x3</code> is now different, whereas <code>x2</code> has the same order just with
index 1 removed.</p>
<h3>Length and capacity of a sequence</h3>
<p>Consider the following code:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> x = newSeq[<span class="hljs-built_in">int</span>]()
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; <span class="hljs-number">10</span>:
  x.add i</code></pre>
                        <p>A naive implementation of a sequence would have to reallocate the memory underlying the sequence for
each call to <code>add</code>. To avoid the overhead of all these copying operations, the implementation
overallocates by a certain amount. This means reallocation is only required if the actual underlying
capacity is exceeded.</p>
<p>This has practical use cases as well. Sometimes we may not know <em>exactly</em> how many elements we will
store in a sequence, but we have a good idea of the order. In those cases we cannot very well create
a sequence with an existing length using <code>newSeq</code> (if we overestimate we suddenly have a number of
empty entries).</p>
<p>For that usecase we can use <code>newSeqOfCap</code>. It creates a sequence of length 0 but whose capacity is the
given number:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> x = newSeqOfCap[<span class="hljs-built_in">int</span>](<span class="hljs-number">100</span>)
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Length: &quot;</span>, x.len</code></pre><pre class="nb-output">Length: 0</pre>
                        <p>As we can see the sequence is currently empty. But if we add to it, the sequence won't have to
reallocate several times. In this way we can often get away with at most one reallocation or
zero, if we accept a bit of overallocation.</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">var</span> x = newSeqOfCap[<span class="hljs-built_in">int</span>](<span class="hljs-number">100</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; <span class="hljs-number">100</span>:
  x.add i</code></pre>
                        <p>So this operation won't reallocate.</p>
<p>Note: for even more performance critical code there is also <code>newSeqUninitialized</code>, which creates a
sequence of N elements that are <em>not</em> zero initialized to save one more (possibly useless) loop
over the memory.</p>
<h3>Filling a seq with a fixed value</h3>
<p>Sometimes we wish to create a sequence that is initialized not to zero, but some other constant
value. For this we can use <code>newSeqWith</code> from <code>sequtils</code>:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> sequtils
<span class="hljs-keyword">echo</span> newSeqWith(<span class="hljs-number">3</span>, <span class="hljs-number">5.5</span>)</code></pre><pre class="nb-output">@[5.5, 5.5, 5.5]</pre>
                        <p>which takes as the first argument the size of the resulting sequence and as the second argument the
value to initialize all values to.</p>
<p>Note: this can also be used to create nested sequences:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> newSeqWith(<span class="hljs-number">3</span>, newSeqWith(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))</code></pre><pre class="nb-output">@[@[5, 5, 5], @[5, 5, 5], @[5, 5, 5]]</pre>
                        <p>which gives us a nested sequence of <code>seq[seq[int]]</code> where each element is a sequence of
integers with value 5.</p>
<h3>A few more typical ways to create sequences</h3>
<p>To finish of this section, let's look at a few more sequence constructors that are often useful.</p>
<p>Nim supports slices using the syntax <code>a .. b</code>, which includes all values from <code>a</code> to including <code>b</code>.
Together with <code>toSeq</code> it can be used to generate a sequence:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> toSeq(<span class="hljs-number">10</span> .. <span class="hljs-number">14</span>)</code></pre><pre class="nb-output">@[10, 11, 12, 13, 14]</pre>
                        <p>This essentially takes the role of <code>arange</code> from numpy. Of course this only generates sequences of integers.</p>
<p>For succinctness (but not performance) we can convert such a sequence using <code>mapIt</code> to map
each element from an input type to some other type:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">echo</span> toSeq(<span class="hljs-number">10</span> .. <span class="hljs-number">14</span>).mapIt(it.<span class="hljs-built_in">float</span>)</code></pre><pre class="nb-output">@[10.0, 11.0, 12.0, 13.0, 14.0]</pre>
                        <p>Returns a sequence of floats instead.</p>
<p>Similarly, it is often desirable to get a linearly spaced sequence of numbers. <code>numericalnim</code> also
provides a <code>linspace</code> implementation. Let's create 5 evenly spaced points between 1 and 2:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> numericalnim
<span class="hljs-keyword">echo</span> linspace(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">5</span>)</code></pre><pre class="nb-output">@[1.0, 1.25, 1.5, 1.75, 2.0]</pre>
                        <p>Finally, one may need a sequence of randomly sampled numbers. The <code>random</code> module of the Nim
standard library provides a <code>rand</code> procedure we can combine with <code>mapIt</code>:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> random
randomize()
<span class="hljs-keyword">echo</span> toSeq(<span class="hljs-number">0</span> ..&lt; <span class="hljs-number">5</span>).mapIt(rand(<span class="hljs-number">10.0</span>))</code></pre><pre class="nb-output">@[3.248404591893539, 0.8147250549024365, 6.561275897577749, 8.244125886845488, 8.793871974402697]</pre>
                        <p>samples 5 floating point numbers between 0 and 10.</p>
<h2><code>Tensor[T]</code> - an ND-array type from <a href="https://github.com/mratsim/Arraymancer">Arraymancer</a></h2>
<p>Arraymancer provides an ND-array type called <code>Tensor[T]</code> that is best compared to a numpy
ndarray. Same as a sequence <code>seq[T]</code> it can only contain a single type. In contrast to it
however, it cannot be resized easily (only <em>reshaped</em>).</p>
<p>Under the hood the data is stored as a pointer + length pair for types that can be copied
using <code>copyMem</code> (Nim's <code>memcpy</code>). Otherwise it contains a <code>seq[T]</code> for the data. The major
difference between a sequence and a tensor is the ability to handle multidimensional data
efficiently.</p>
<p>In case of a <code>seq[T]</code> we either have to manually handle the indexing of the sequence (if we
store ND data in a 1D sequence) or deal with the inefficiencies of a nested sequence <code>seq[seq[T]]</code>.
In that case <em>every</em> access requires an additional pointer indirection.</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> x = @[ @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], @[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] ]
<span class="hljs-keyword">echo</span> x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]</code></pre><pre class="nb-output">4</pre>
                        <p>The access <code>[1][0]</code> in this example first returns a sequence, which we have to dereference
<em>again</em> to get to an element. This makes accessing data expensive.
An Arraymancer tensor on the other hand always stores data in a one-dimensional data storage.
Not only does it make iterating over and accessing data faster, it also allows for essentially
free reshaping of the data, because the shape is only a piece of meta data.</p>
<p>Another important bit of information is that tensors have reference semantics. That means
assigning a tensor to a new variable and modifying that variable also modifies the initial
tensor! This is for efficiency reasons to not copy all the data for each assignment.</p>
<p>Two most basic ways to create are shown below:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> arraymancer
<span class="hljs-keyword">let</span> t = @[<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>].toTensor</code></pre>
                        <p>First we can just create a tensor from a (possibly nested) sequence or array using <code>toTensor</code>.</p>
<p>Secondly:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> t = newTensor[<span class="hljs-built_in">float</span>](<span class="hljs-number">9</span>)</code></pre>
                        <p>This is the default tensor constructor. It creates a tensor of type <code>Tensor[float]</code> with
10 elements that is zero initialized. If multiple elements are given to the procedure a tensor
of different shape is created.</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> t = newTensor[<span class="hljs-built_in">float</span>](<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)</code></pre>
                        <p>creates a tensor 2 dimensional tensor of size 3 in both dimensions (essentiall a 3x3 matrix).</p>
<p>Note that due to the shape being a piece of meta data, it is cheap to convert from one shape
to another using <code>reshape</code>.</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> t = newTensor[<span class="hljs-built_in">float</span>](<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)</code></pre>
                        <p>This essentially does not have any meaningful overhead over the creation of <code>t3</code> above.</p>
<p>Some more ways to construct a tensor:</p>
                        <pre><code class="nohighlight hljs nim"><span class="hljs-keyword">let</span> t1 = zeros[<span class="hljs-built_in">float</span>](<span class="hljs-number">9</span>) <span class="hljs-comment">## a tensor that is explicit 0, the default</span>
<span class="hljs-keyword">let</span> t2 = ones[<span class="hljs-built_in">float</span>](<span class="hljs-number">9</span>) <span class="hljs-comment">## a tensor that is initialized to 1</span>
<span class="hljs-keyword">let</span> t3 = newTensorWith[<span class="hljs-built_in">float</span>]([<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], <span class="hljs-number">5</span>) <span class="hljs-comment">## a 3x3 tensor initialized to 5</span>
<span class="hljs-keyword">let</span> t4 = newTensorUninit[<span class="hljs-built_in">float</span>](<span class="hljs-number">10</span>) <span class="hljs-comment">## a tensor that is *not* initialized</span>
<span class="hljs-keyword">let</span> t5 = arange(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">## the range 0 to 10 as a `Tensor[int]`</span>
<span class="hljs-keyword">let</span> t6 = linspace(<span class="hljs-number">0.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">1000</span>) <span class="hljs-comment">## 1000 linearly spaced points between 0 and 10</span></code></pre>
                        <p>These are only a few common ways to create a tensor.</p>
<h3>Access and mutation</h3>
<p>Arraymancer tensors are very similar to the Nim standard library <code>seq[T]</code> in terms of
their element access and element mutation, with the aforementioned difference of reference
semantics.</p>
<p>However, because tensors deal with possibly multidimensional data, there are ways to
slice and select parts of a tensor using syntax comparable to numpy's fancy indexing.
Furthermore, support for element-wise operations between multiple tensors are supported.</p>
<p>As we won't make use of that in this tutorial, we won't cover it here. See the Arraymancer
<a href="https://mratsim.github.io/Arraymancer/tuto.slicing.html">tutorial section</a> to get an idea.</p>
<h3>More</h3>
<p>Of course Arraymancer provides a large amount of additional functionality, starting from
linear algebra, to statistics, machine learning and more. View the full documentation here:</p>
<p><a href="https://mratsim.github.io/Arraymancer/">Arraymancer documentation</a></p>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basics/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basics/data_wrangling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basics/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basics/data_wrangling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>







        <script src="../assets/js/clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../assets/js/book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
