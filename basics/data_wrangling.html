<!DOCTYPE HTML>
<html lang="en-us" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using nimibook -->
        <meta charset="UTF-8">
        <title>basics/data_wrangling.nim</title>

        <!-- Custom HTML head -->
        <!-- custom head content -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="a book built with nimibook">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
        <link rel="stylesheet" href="../assets/css/variables.css">
        <link rel="stylesheet" href="../assets/css/general.css">
        <link rel="stylesheet" href="../assets/css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../assets/FontAwesome/css/font-awesome.min.css">

        <!-- Highlight.js Stylesheets - I could use nimib native highlight but let's keep it for styling... -->
        <link rel="stylesheet" href="../assets/css/highlight.css">
        <link rel="stylesheet" href="../assets/css/tomorrow-night.css">
        <link rel="stylesheet" href="../assets/css/ayu-highlight.css">

        <!-- Custom theme stylesheets - why the "../"? -->


        <!-- plausible analytics (new in nimibook) -->
        <script defer data-domain="scinim.github.io/getting-started" src="https://plausible.io/js/plausible.js"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "..//assets";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                                <ol class="chapter">
                  <li class="chapter-item expanded ">
                    <a href="../index.html" tabindex="0">
                      <strong aria-hidden="true">1.</strong> Introduction
                    </a>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../overview/index.html" tabindex="0">
                      <strong aria-hidden="true">2.</strong> Ecosystem overview
                    </a>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../basics/index.html" tabindex="0">
                      <strong aria-hidden="true">3.</strong> Basic topics
                    </a>
                  </li>
                  <li>
                  <ol class="section">
                  <li class="chapter-item expanded ">
                    <a href="../basics/common_datatypes.html" tabindex="0">
                      <strong aria-hidden="true">3.1.</strong> Common datatypes
                    </a>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../basics/data_wrangling.html" class="active" tabindex="0">
                      <strong aria-hidden="true">3.2.</strong> Data wrangling with dataframes
                    </a>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../basics/basic_plotting.html" tabindex="0">
                      <strong aria-hidden="true">3.3.</strong> Plotting
                    </a>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../basics/units_basics.html" tabindex="0">
                      <strong aria-hidden="true">3.4.</strong> Units
                    </a>
                  </li>
                  </ol>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../numerical_methods/index.html" tabindex="0">
                      <strong aria-hidden="true">4.</strong> Numerical methods
                    </a>
                  </li>
                  <li>
                  <ol class="section">
                  <li class="chapter-item expanded ">
                    <a href="../numerical_methods/curve_fitting.html" tabindex="0">
                      <strong aria-hidden="true">4.1.</strong> Curve fitting
                    </a>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../numerical_methods/integration1d.html" tabindex="0">
                      <strong aria-hidden="true">4.2.</strong> Integration (1D)
                    </a>
                  </li>
                  </ol>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../data_viz/index.html" tabindex="0">
                      <strong aria-hidden="true">5.</strong> Data visualization
                    </a>
                  </li>
                  <li>
                  <ol class="section">
                  <li class="chapter-item expanded ">
                    <a href="../data_viz/plotting_data.html" tabindex="0">
                      <strong aria-hidden="true">5.1.</strong> Plotting data
                    </a>
                  </li>
                  </ol>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../external_language_integration/index.html" tabindex="0">
                      <strong aria-hidden="true">6.</strong> Interfacing with other language
                    </a>
                  </li>
                  <li>
                  <ol class="section">
                  <li class="chapter-item expanded ">
                    <a href="../external_language_integration/nim_with_py.html" tabindex="0">
                      <strong aria-hidden="true">6.1.</strong> Nimpy - The Nim Python bridge
                    </a>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../external_language_integration/julia/basics.html" tabindex="0">
                      <strong aria-hidden="true">6.2.</strong> Nimjl - The Nim Julia bridge
                    </a>
                  </li>
                  <li>
                  <ol class="section">
                  <li class="chapter-item expanded ">
                    <a href="../external_language_integration/julia/nimjl_conversions.html" tabindex="0">
                      <strong aria-hidden="true">6.2.1.</strong> Advanced types
                    </a>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../external_language_integration/julia/nimjl_arrays.html" tabindex="0">
                      <strong aria-hidden="true">6.2.2.</strong> Julia Arrays from Nim
                    </a>
                  </li>
                  </ol>
                  </li>
                  <li class="chapter-item expanded ">
                    <a href="../external_language_integration/nim_with_R.html" tabindex="0">
                      <strong aria-hidden="true">6.3.</strong> Interfacing with R
                    </a>
                  </li>
                </ol>
<!-- I could use also an unescaped context value -->
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <!-- custom header content -->                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">SciNim Getting Started</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/SciNim/getting-started" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1>Data wrangling using the <code>DataFrame</code> from <a href="https://github.com/SciNim/Datamancer">Datamancer</a></h1>
<p>The third major data type often encountered is a <code>DataFrame</code>.</p>
<p>Data frames can be thought of as multiple, named tensors of possibly different types
in one object. A data frame library then is supposed to make working with such data
as convenient and powerful as possible.</p>
<p>In the specific case of Datamancer, the data structure is essentially an
<code>OrderedTable[string, Column]</code>, where <code>Column</code> is a variant object storing one
of 5 different <code>Tensor[T]</code> types.</p>
<p>In order to use Datamancer, you must first import it. In addition to that, in this tutorial
we will also import the <a href="https://github.com/mratsim/Arraymancer">Arraymancer</a> tensor library,
which we will use to demonstrate that you can create dataframes from Arraymancer tensors.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">import</span>
  datamancer

<span class="hljs-keyword">import</span>
  arraymancer</code></pre>
<h2>Construction of a <code>DataFrame</code></h2>
<p>A <code>DataFrame</code> from the Datamancer library can be constructed in two different ways. Either
from an input CSV file or from existing sequences or tensors.</p>
<p>Construction from a CSV file is performed using the <code>readCsv</code> procedure. It provides multiple
different options (different separators, skipping lines, header symbols, ...), but for a
regular comma separated value file, the defaults are fine. For example:</p>
<pre><code class="language-nim">let df1 = readCsv(&quot;foo.csv&quot;)
echo df1
</code></pre>
<p>Alternatively, if one already has a mix of sequences and tensors of the same length:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> s1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> s2 = @[<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>]
<span class="hljs-keyword">let</span> s3 = @[<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>].toTensor
<span class="hljs-keyword">let</span> df2 = toDf(s1, s2, s3)
<span class="hljs-keyword">echo</span> df2
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Column names: &quot;</span>, df2.getKeys() <span class="hljs-comment">## getKeys only returns the column names</span></code></pre>
<pre><samp>Dataframe with 3 columns and 3 rows:
       Idx        s1        s2        s3
    dtype:       int    string     float
         0         1     hello       1.5
         1         2       foo       2.5
         2         3       bar       3.5

Column names: @[&quot;s1&quot;, &quot;s2&quot;, &quot;s3&quot;]
</samp></pre>
<p>which creates a data frame with three columns named <code>&quot;s1&quot;, &quot;s2&quot;, &quot;s3&quot;</code>. We can see that
mixing different input types is not a problem. The supported types are</p>
<ul>
<li><code>float</code></li>
<li><code>int</code></li>
<li><code>string</code></li>
<li><code>bool</code></li>
</ul>
<p>and a mix of them in one column.</p>
<p>Printing a data frame by default prints the first 20 rows. This can be adjusted by calling
the <code>pretty</code> procedure manually and handing the number of rows (-1 for all).</p>
<p>In addition one can always view a data frame in the browser by doing <code>showBrowser(df)</code> where
<code>df</code> is the data frame to view.</p>
<p>If one wishes to name the columns differently from construction (they can be renamed later
as well), it is done by:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df3 = toDf({<span class="hljs-string">&quot;Id&quot;</span>: s1, <span class="hljs-string">&quot;Word&quot;</span>: s2, <span class="hljs-string">&quot;Number&quot;</span>: s3})
<span class="hljs-keyword">echo</span> df3</code></pre>
<pre><samp>Dataframe with 3 columns and 3 rows:
       Idx        Id      Word    Number
    dtype:       int    string     float
         0         1     hello       1.5
         1         2       foo       2.5
         2         3       bar       3.5

</samp></pre>
<p>Finally, one can also create a <code>DataFrame</code> starting from an empty object and
assigning sequences, tensors or scalar values manually:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">var</span> df = newDataFrame()
df[<span class="hljs-string">&quot;x&quot;</span>] = @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]         <span class="hljs-comment">## assign a sequence. This sets the `DataFrame` length to 3</span>
df[<span class="hljs-string">&quot;y&quot;</span>] = @[<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>].toTensor <span class="hljs-comment">## assign a tensor. Input now `must` match length 3</span>
<span class="hljs-keyword">try</span>:
  df[<span class="hljs-string">&quot;z&quot;</span>] = @[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]          <span class="hljs-comment">## raises</span>
<span class="hljs-keyword">except</span> <span class="hljs-type">ValueError</span>:
  <span class="hljs-keyword">discard</span>                   <span class="hljs-comment">## type of exception might change in the future</span>
df[<span class="hljs-string">&quot;z&quot;</span>] = constantColumn(<span class="hljs-number">1</span>, df.len) <span class="hljs-comment">## assign a constant column of integers.</span></code></pre>
<h2>Accessing data underlying a column</h2>
<p>The data stored in a column of a data frame can always be accessed easily. Because the
data is stored in a variant object, the user needs to supply the data type to use to
read the data as. Nim does <em>not</em> allow return type overloading, which means we cannot
use the runtime information about the types to return the &quot;correct&quot; tensor. All we can
make sure is that accessing the data with the <em>correct</em> type is a no-op.</p>
<p>This has the downside that an invalid type will produce a runtime error. On the upside
it allows us to perform type conversions directly, for instance reading an integer column
as floats or any column as strings.</p>
<p>The syntax is as follows:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>]})
<span class="hljs-keyword">let</span> t1: <span class="hljs-type">Tensor</span>[<span class="hljs-built_in">int</span>] = df[<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-built_in">int</span>] <span class="hljs-comment">## this is a no-op</span>
<span class="hljs-keyword">let</span> t2: <span class="hljs-type">Tensor</span>[<span class="hljs-built_in">float</span>] = df[<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-built_in">float</span>] <span class="hljs-comment">## converts integers to floats</span>
<span class="hljs-keyword">let</span> t3: <span class="hljs-type">Tensor</span>[<span class="hljs-built_in">float</span>] = df[<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-built_in">float</span>] <span class="hljs-comment">## also a no-op</span>
<span class="hljs-keyword">let</span> t4: <span class="hljs-type">Tensor</span>[<span class="hljs-built_in">string</span>] = df[<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-built_in">string</span>] <span class="hljs-comment">## convert to string</span>
<span class="hljs-keyword">try</span>:
  <span class="hljs-keyword">let</span> t5: <span class="hljs-type">Tensor</span>[<span class="hljs-built_in">bool</span>] = df[<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-built_in">bool</span>] <span class="hljs-comment">## would produce a runtime error</span>
<span class="hljs-keyword">except</span> <span class="hljs-type">ValueError</span>:
  <span class="hljs-keyword">discard</span>                   <span class="hljs-comment">## type of exception might be changed in the future</span></code></pre>
<p>where we indicate the types explicitly on the left hand side for clarity.</p>
<p>This means we can in principle always access individual elements of a data frame column
by getting the tensor and accessing elements from it. Of course this has some overhead,
but due to reference semantics it is relatively cheap (no data is copied, unless type
conversions need to be performed).</p>
<h2>Computing single column aggregations</h2>
<p>As we saw in the previous section, accessing a tensor of a column is cheap. We can
use that to perform aggregations on full columns:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>]})
<span class="hljs-keyword">echo</span> df[<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-built_in">int</span>].sum
<span class="hljs-keyword">echo</span> df[<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-built_in">float</span>].mean</code></pre>
<pre><samp>6
5.0
</samp></pre>
<p>and in that sense any operation acting on tensors can be used.</p>
<h2>Data frame operations</h2>
<p>In the more general case (the reason one uses a data frame in the first place) we
don't want to only consider a single column.</p>
<p>Many different operations are supported, but can be grouped into a few general procedures.</p>
<p>Some of the procedures of Datamancer take so called <code>FormulaNodes</code>. They are essentially
a domain specific language to succinctly express operations on data frame columns
without the need to fully refer to them. Their basic construction and usage should become
clear in the code below. The Datamancer documentation contains a much deeper introduction
into the specifics here:</p>
<p><a href="https://scinim.github.io/Datamancer/datamancer.html#formulas">Formula introduction</a></p>
<h3><code>select</code> - Selecting a subset of columns</h3>
<p>If we have a data frame with multiple columns we may want to keep only
a subset of these going forward. This can be achieved using <code>select</code>:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">var</span> df = newDataFrame()
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; <span class="hljs-number">100</span>:
  df[<span class="hljs-string">&quot;x&quot;</span> &amp; $i] = @[<span class="hljs-number">1</span> + i, <span class="hljs-number">2</span> + i, <span class="hljs-number">3</span> + i]
<span class="hljs-keyword">echo</span> df.select(<span class="hljs-string">&quot;x1&quot;</span>, <span class="hljs-string">&quot;x50&quot;</span>, <span class="hljs-string">&quot;x99&quot;</span>)</code></pre>
<pre><samp>Dataframe with 3 columns and 3 rows:
       Idx        x1       x50       x99
    dtype:       int       int       int
         0         2        51       100
         1         3        52       101
         2         4        53       102

</samp></pre>
<p>which drops every column not selected.</p>
<p>The inverse is also possible using <code>drop</code>:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>], <span class="hljs-string">&quot;z&quot;</span>: @[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]})
<span class="hljs-keyword">echo</span> df.drop(<span class="hljs-string">&quot;x&quot;</span>)</code></pre>
<pre><samp>Dataframe with 2 columns and 3 rows:
       Idx         y         z
    dtype:     float    string
         0         4         a
         1         5         b
         2         6         c

</samp></pre>
<h3><code>rename</code> - Renaming a column</h3>
<p><code>rename</code>, as the name implies, is used to rename columns. Usage is rather simple. We'll
get our first glance at the <code>f{}</code> macro to generate a <code>FormulaNode</code> here:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>]})
<span class="hljs-keyword">echo</span> df.rename(f{<span class="hljs-string">&quot;foo&quot;</span> &lt;- <span class="hljs-string">&quot;x&quot;</span>})</code></pre>
<pre><samp>Dataframe with 2 columns and 3 rows:
       Idx         y       foo
    dtype:     float       int
         0         4         1
         1         5         2
         2         6         3

</samp></pre>
<p>So we can see that we simply assign <code>&lt;-</code> the old name &quot;x&quot; to the new name &quot;foo&quot;.</p>
<h3><code>arrange</code> - Sorting a data frame</h3>
<p>Often we wish to sort a data frame by one or more columns. This is done using <code>arrange</code>.
It can take one or more columns to sort by, where for multiple columns the order
of the inputs decides the precedence of what to sort by first, the later columns only
used to break ties between the former.</p>
<p>The sort order is handled in the same way as in Nim's standard library, i.e. using
an <code>order</code> argument that takes either <code>SortOrder.Ascending</code> or <code>SortOrder.Descending</code>.
The default order is ascending order.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-number">2.3</span>, <span class="hljs-number">7.1</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">1.0</span>],
               <span class="hljs-string">&quot;z&quot;</span>: @[<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>]})
<span class="hljs-keyword">echo</span> df.arrange(<span class="hljs-string">&quot;x&quot;</span>)         <span class="hljs-comment">## sort by `x` in ascending order (default)</span>
<span class="hljs-keyword">echo</span> df.arrange(<span class="hljs-string">&quot;x&quot;</span>, order = <span class="hljs-type">SortOrder</span>.<span class="hljs-type">Descending</span>) <span class="hljs-comment">## sort in descending order</span>
<span class="hljs-keyword">echo</span> df.arrange([<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>])  <span class="hljs-comment">## sort by two columns, first `x` then `z` to break ties</span></code></pre>
<pre><samp>Dataframe with 3 columns and 4 rows:
       Idx         x         y         z
    dtype:       int     float    string
         0         2       7.1         c
         1         4       2.3         b
         2         4         1         a
         3         7       3.3         d

Dataframe with 3 columns and 4 rows:
       Idx         x         y         z
    dtype:       int     float    string
         0         7       3.3         d
         1         4       2.3         b
         2         4         1         a
         3         2       7.1         c

Dataframe with 3 columns and 4 rows:
       Idx         x         y         z
    dtype:       int     float    string
         0         2       7.1         c
         1         4         1         a
         2         4       2.3         b
         3         7       3.3         d

</samp></pre>
<h3><code>unique</code> - Removing duplicate rows</h3>
<p>Another useful operation is removal of duplicate entries. <code>unique</code> is the procedure
to use. If no argument is given uniqueness is determined based on <em>all</em> existing
columns. This is not always the most desired option of course, which is why <code>unique</code>
accepts a variable number of columns. Then only uniqueness among these columns is
considered.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-number">5.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span>, <span class="hljs-number">9.0</span>],
               <span class="hljs-string">&quot;z&quot;</span>: @[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>]})
<span class="hljs-keyword">echo</span> df.unique()             <span class="hljs-comment">## consider uniqueness of all columns, nothing removed</span>
<span class="hljs-keyword">echo</span> df.unique(<span class="hljs-string">&quot;x&quot;</span>)          <span class="hljs-comment">## only consider `x`, only keeps keeps 1st, 2nd, last row</span>
<span class="hljs-keyword">echo</span> df.unique([<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>])   <span class="hljs-comment">## considers `x` and `z`, one more unique (4th row)</span></code></pre>
<pre><samp>Dataframe with 3 columns and 5 rows:
       Idx         x         y         z
    dtype:       int     float    string
         0         1         5         a
         1         2         6         b
         2         2         7         b
         3         2         8         d
         4         4         9         e

Dataframe with 3 columns and 3 rows:
       Idx         x         y         z
    dtype:       int     float    string
         0         1         5         a
         1         2         6         b
         2         4         9         e

Dataframe with 3 columns and 4 rows:
       Idx         x         y         z
    dtype:       int     float    string
         0         1         5         a
         1         2         6         b
         2         2         8         d
         3         4         9         e

</samp></pre>
<h3><code>mutate</code> - Creating new or modifying existing columns</h3>
<p><code>mutate</code> is the procedure to use to add new columns to a data frame or modify
existing ones. For this procedure we need to hand formulas using the <code>f{}</code> macro
again. Here it is advisable to name the formulas. Instead of the above assignment
operator <code>&lt;-</code> we now use the &quot;x depends on y&quot; operator <code>~</code>.</p>
<p>Further, to refer to a column in the computation we perform we will use accented
quotes. This is all the complexity of that macro we will discuss in this introduction.</p>
<p>Let's compute the sum of two columns to get a feel:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]})
<span class="hljs-keyword">echo</span> df.mutate(f{<span class="hljs-string">&quot;x+y&quot;</span> ~ `x` + `y`})</code></pre>
<pre><samp>Dataframe with 3 columns and 3 rows:
       Idx         x         y       x+y
    dtype:       int       int     float
         0         1        10        11
         1         2        11        13
         2         3        12        15

</samp></pre>
<p>Of course we can use constants and local Nim symbols as well:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]})
<span class="hljs-keyword">echo</span> df.mutate(f{<span class="hljs-string">&quot;x+5&quot;</span> ~ `x` + <span class="hljs-number">5</span>})
<span class="hljs-keyword">let</span> y = <span class="hljs-number">2.0</span>
<span class="hljs-keyword">echo</span> df.mutate(f{<span class="hljs-string">&quot;x + local y&quot;</span> ~ `x` + y})</code></pre>
<pre><samp>Dataframe with 2 columns and 3 rows:
       Idx         x       x+5
    dtype:       int       int
         0         1         6
         1         2         7
         2         3         8

Dataframe with 2 columns and 3 rows:
            Idx              x    x + local y
         dtype:            int          float
              0              1              3
              1              2              4
              2              3              5

</samp></pre>
<p>Note: There is a slight subtlety at play here. If you look closely at the output of
these two <code>mutate</code> commands you see that in the first case the resulting column is
of type <code>int</code>, whereas in the second case it's <code>float</code>. That is because the type
of the column is deduced based on the types in the rest of the formula. <code>5</code> is an
<code>int</code> so <code>x</code> is read as integers in the first case, whereas <code>y</code> is a <code>float</code> and so
<code>x</code> is read as a <code>float</code>. See the Datamancer documentation on details and how to
specify the types manually.</p>
<p>And as stated we can also overwrite columns:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]})
<span class="hljs-keyword">echo</span> df.mutate(f{<span class="hljs-string">&quot;x&quot;</span> ~ `x` + `x`})</code></pre>
<pre><samp>Dataframe with 1 columns and 3 rows:
       Idx         x
    dtype:     float
         0         2
         1         4
         2         6

</samp></pre>
<p>Under the hood these formulas are converted into a closure that takes a data frame
as an input. The column references are extracted and converted into a preamble
that reads the corresponding tensors. Then we run over the relevant tensors and
perform the described operation for each element. The result is assigned to
a resulting tensor, which is assigned as the new column.</p>
<p>The only restriction on the body of the formula is that it's a valid Nim expression
(if one mentally replaces column references by tensor elements) that returns a
value of a valid data type for a data frame.</p>
<p>If one wishes the same behavior as <code>mutate</code> but does not require the columns anymore
that are not explicitly created / modified using a formula, there is <code>transmute</code> for
this purpose. Otherwise it is equivalent to <code>mutate</code>.</p>
<h3><code>filter</code> - Removing rows based on a predicate</h3>
<p>These mentioned formulas can of course also return boolean values. In combination
with the <code>filter</code> procedure this allows us to remove rows of a data frame that
fail to pass a condition (or a &quot;predicate&quot;).</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>]})
<span class="hljs-keyword">echo</span> df.filter(f{`x` &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> `y` == <span class="hljs-string">&quot;e&quot;</span>})</code></pre>
<pre><samp>Dataframe with 2 columns and 3 rows:
       Idx         x         y
    dtype:       int    string
         0         1         a
         1         2         b
         2         5         e

</samp></pre>
<h3><code>summarize</code> - Computing aggregations on a full data frame</h3>
<p>The approach described in &quot;Computing single column aggregations&quot; can be useful for
simple single column operations, but does not scale well. That's what <code>summarize</code> is
for. Here we use the last operator used in the <code>f{}</code> macro, namely the reduction
<code>&lt;&lt;</code> operator:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;x&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-string">&quot;y&quot;</span>: @[<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>]})
<span class="hljs-keyword">echo</span> df.summarize(f{<span class="hljs-built_in">float</span>: mean(`x`)}) <span class="hljs-comment">## compute mean, auto creates a column name</span>
<span class="hljs-keyword">echo</span> df.summarize(f{<span class="hljs-built_in">float</span>: <span class="hljs-string">&quot;mean(x)&quot;</span> &lt;&lt; mean(`x`)}) <span class="hljs-comment">## same but with a custom name</span>
<span class="hljs-keyword">echo</span> df.summarize(f{<span class="hljs-string">&quot;mean(x)+sum(y)&quot;</span> &lt;&lt; mean(`x`) + sum(`y`)})</code></pre>
<pre><samp>Dataframe with 1 columns and 1 rows:
         Idx    (mean x)
      dtype:       float
           0           3

Dataframe with 1 columns and 1 rows:
        Idx    mean(x)
     dtype:      float
          0          3

Dataframe with 1 columns and 1 rows:
               Idx    mean(x)+sum(y)
            dtype:             float
                 0                78

</samp></pre>
<p>Keen eyes will notice the <code>float:</code> at the beginning of the first two examples. This is
a &quot;type hint&quot; for the formula, because the symbol &quot;mean&quot; is overloaded in Nim. But not
by a few distinct procedures, but generically. At this moment there are no heuristics
involved to choose one type over another in a generic case. Therefore, we don't know
what type <code>x</code> should be read as. So we overwrite the input type manually and give the
macro a hint.</p>
<p>If we leave out the type information you will be greeted with a message of the type
information found of <code>mean</code> and to consider giving such a type hint.</p>
<p>The situation is slightly different for the last case, in which an addition is involved.
Due to some heuristic rules involving the most basic operators (maths and boolean) we can
determine here that the input is probably supposed to be float.</p>
<h3><code>group_by</code></h3>
<p><code>summarize</code> and the other procedures can be spiced up if used in combination with
<code>group_by</code>.</p>
<p><code>group_by</code> by itself doesn't perform any operations. It simply returns a new data frame
with the exact same data that is now &quot;grouped&quot; by one or more columns. These columns should
be columns containing <em>discrete</em> data. This grouping can be used (manually or indirectly)
via the <code>groups</code> iterator. It yields all &quot;sub data frames&quot; contained in the grouped data
frame. These sub data frames are those of duplicate entries in the columns that we have
grouped by. It essentially yields everything as a sub data frame that would be reduced
to a single row if using <code>unique</code> on the same columns as grouped by.</p>
<p>This should become clearer with an example:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;Class&quot;</span>: @[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>],
               <span class="hljs-string">&quot;Num&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>]}).group_by(<span class="hljs-string">&quot;Class&quot;</span>)
<span class="hljs-keyword">for</span> t, subDf <span class="hljs-keyword">in</span> groups(df):
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Sub data frame: &quot;</span>, t
  <span class="hljs-keyword">echo</span> subDf</code></pre>
<pre><samp>Sub data frame: @[(&quot;Class&quot;, (kind: VString, str: &quot;A&quot;))]
Dataframe with 2 columns and 2 rows:
       Idx     Class       Num
    dtype:    string       int
         0         A         1
         1         A         8

Sub data frame: @[(&quot;Class&quot;, (kind: VString, str: &quot;B&quot;))]
Dataframe with 2 columns and 2 rows:
       Idx     Class       Num
    dtype:    string       int
         0         B         3
         1         B         4

Sub data frame: @[(&quot;Class&quot;, (kind: VString, str: &quot;C&quot;))]
Dataframe with 2 columns and 3 rows:
       Idx     Class       Num
    dtype:    string       int
         0         C         5
         1         C         7
         2         C         2

</samp></pre>
<p>We can see we have 3 sub data frames. One for each discrete value found in column <code>Class</code>.</p>
<p>The actually interesting applications of <code>groub_by</code> though is its combination with one
of the other procedures shown above, in particular <code>summarize</code>, <code>filter</code> and <code>mutate</code>.
For a grouped data frame these operations will then performed <em>group wise</em>. Operations
that only use information of a single row are unaffected by this. But any formula that
includes a reference to a full column (<code>mean, sum, ...</code>) will compute this value per
group.</p>
<p>A few examples:</p>
<ul>
<li><code>summarize</code></li>
</ul>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;Class&quot;</span>: @[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>],
               <span class="hljs-string">&quot;Num&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]})
<span class="hljs-keyword">echo</span> df.group_by(<span class="hljs-string">&quot;Class&quot;</span>).summarize(f{<span class="hljs-built_in">int</span>: <span class="hljs-string">&quot;sum(Num)&quot;</span> &lt;&lt; sum(`<span class="hljs-type">Num</span>`)})</code></pre>
<pre><samp>Dataframe with 2 columns and 3 rows:
         Idx       Class    sum(Num)
      dtype:      string         int
           0           A           9
           1           B           7
           2           C          14

</samp></pre>
<p>We can see this computes the sum for each class now.</p>
<ul>
<li><code>filter</code>:</li>
</ul>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;Class&quot;</span>: @[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>],
               <span class="hljs-string">&quot;Num&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]})
<span class="hljs-keyword">echo</span> df.group_by(<span class="hljs-string">&quot;Class&quot;</span>).filter(f{sum(`<span class="hljs-type">Num</span>`) &lt;= <span class="hljs-number">9</span>})</code></pre>
<pre><samp>Dataframe with 2 columns and 6 rows:
       Idx     Class       Num
    dtype:    string       int
         0         A         1
         1         A         8
         2         A         0
         3         B         3
         4         B         4
         5         B         0

</samp></pre>
<p>and again, the filtering is done per group. In this sense a filtering operation
that uses a reducing formula as input would usually not make too much sense anyway.</p>
<ul>
<li><code>mutate</code>:</li>
</ul>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;Class&quot;</span>: @[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>],
               <span class="hljs-string">&quot;Num&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]})
<span class="hljs-keyword">echo</span> df.group_by(<span class="hljs-string">&quot;Class&quot;</span>).mutate(f{<span class="hljs-string">&quot;Num - mean&quot;</span> ~ `<span class="hljs-type">Num</span>` - mean(`<span class="hljs-type">Num</span>`)})</code></pre>
<pre><samp>Dataframe with 3 columns and 9 rows:
           Idx         Class           Num    Num - mean
        dtype:        string           int         float
             0             A             1            -2
             1             A             8             5
             2             A             0            -3
             3             B             3        0.6667
             4             B             4         1.667
             5             B             0        -2.333
             6             C             5        0.3333
             7             C             7         2.333
             8             C             2        -2.667

</samp></pre>
<p>where we subtract the mean (of each class!) from each observation.</p>
<p>If one uses multiple columns to group by, we get instead the sub data frame corresponding
to each unique combination of discrete values. Feel free to play around and try out
such an example!</p>
<h3><code>gather</code> - Converting a wide format data frame to long format</h3>
<p>As one of the last things to cover, we will quickly talk about data frames in wide and
long format. In a way the example data frame above with a column &quot;Class&quot; and a column
&quot;Num&quot; can be considered a data frame in &quot;long&quot; format. Long format in the sense that
we have one discrete column &quot;Class&quot; that maps to different &quot;Num&quot; values. Because the
column &quot;Class&quot; contains <em>discrete</em> values, We can imagine &quot;transposing&quot; the data frame
to columns &quot;A&quot;, &quot;B&quot;, &quot;C&quot; instead with the values for each of these <em>groups</em> as the values
in the corresponding columns. Let's look at:</p>
<ul>
<li>this data frame</li>
<li>the output of grouping that data frame by &quot;Class&quot;</li>
<li>the same data frame in wide format</li>
</ul>
<p>for clarity:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> dfLong = toDf({<span class="hljs-string">&quot;Class&quot;</span>: @[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>],
                   <span class="hljs-string">&quot;Num&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]})
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Long format:</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>, dfLong
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;----------------------------------------&quot;</span>
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Grouping by `Class`:&quot;</span>
<span class="hljs-keyword">for</span> _, subDf <span class="hljs-keyword">in</span> groups(dfLong.group_by(<span class="hljs-string">&quot;Class&quot;</span>)):
  <span class="hljs-keyword">echo</span> subDf
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;----------------------------------------&quot;</span>
<span class="hljs-keyword">let</span> dfWide = toDf({<span class="hljs-string">&quot;A&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>], <span class="hljs-string">&quot;B&quot;</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>], <span class="hljs-string">&quot;C&quot;</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>]})
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Wide format:</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>, dfWide</code></pre>
<pre><samp>Long format:
Dataframe with 2 columns and 9 rows:
       Idx     Class       Num
    dtype:    string       int
         0         A         1
         1         C         5
         2         B         3
         3         B         4
         4         A         8
         5         C         7
         6         C         2
         7         A         0
         8         B         0

----------------------------------------
Grouping by `Class`:
Dataframe with 2 columns and 3 rows:
       Idx     Class       Num
    dtype:    string       int
         0         A         1
         1         A         8
         2         A         0

Dataframe with 2 columns and 3 rows:
       Idx     Class       Num
    dtype:    string       int
         0         B         3
         1         B         4
         2         B         0

Dataframe with 2 columns and 3 rows:
       Idx     Class       Num
    dtype:    string       int
         0         C         5
         1         C         7
         2         C         2

----------------------------------------
Wide format:
Dataframe with 3 columns and 3 rows:
       Idx         A         B         C
    dtype:       int       int       int
         0         1         3         5
         1         8         4         7
         2         0         0         2

</samp></pre>
<p>As we can see, the difference between wide and long format is the way the <code>groub_by</code> results
are &quot;assembled&quot;. As different columns for each group (wide format) or as two (key, value)
columns (long format).</p>
<p>The conversion from wide -&gt; long format is always possible. But the the mapping of long -&gt; wide
format requires there to be the the same number of entries for each class. If that condition
is not satisfied, there will be missing values in the columns of the separate classes.</p>
<p>Depending on circumstances one might have input data in either order. However, in particular
for plotting purposes the long format is often more convenient as it allows to classify the
discrete classes using different colors, shapes etc. automatically.</p>
<p>Therefore, there is the <code>gather</code> procedure to convert a wide format data frame into a
long format one. It takes the columns to be &quot;gathered&quot;, the name of the column containing
the &quot;keys&quot; (the column from which a value came) and a name for the column of the &quot;values&quot;
that were &quot;gathered&quot;. We can use it to recover the (&quot;Class&quot;, &quot;Num&quot;) data frame from
the last one:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;A&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>], <span class="hljs-string">&quot;B&quot;</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>], <span class="hljs-string">&quot;C&quot;</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>]})
<span class="hljs-keyword">echo</span> df.gather(df.getKeys(), <span class="hljs-comment">## get all keys to gather</span>
               key = <span class="hljs-string">&quot;Class&quot;</span>, <span class="hljs-comment">## the name of the `key` column</span>
               value = <span class="hljs-string">&quot;Num&quot;</span>)</code></pre>
<pre><samp>Dataframe with 2 columns and 9 rows:
       Idx     Class       Num
    dtype:    string       int
         0         A         1
         1         A         8
         2         A         0
         3         B         3
         4         B         4
         5         B         0
         6         C         5
         7         C         7
         8         C         2

</samp></pre>
<p>which is exactly the same data frame as in the examples before.</p>
<p>(Note: the inverse procedure to convert a long format data frame back into wide format
is currently still missing. It will be added soon)</p>
<h3><code>innerJoin</code> - joining two data frames by a common column</h3>
<p>As the last common example of data frame operations, we shall consider joining two
data frames by a common column.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span> df1 = toDf({<span class="hljs-string">&quot;Class&quot;</span>: @[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>], <span class="hljs-string">&quot;Num&quot;</span>: @[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]})
<span class="hljs-keyword">let</span> df2 = toDf({<span class="hljs-string">&quot;Class&quot;</span>: [<span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>],
                <span class="hljs-string">&quot;Ids&quot;</span>: @[<span class="hljs-number">123</span>, <span class="hljs-number">124</span>, <span class="hljs-number">125</span>, <span class="hljs-number">126</span>, <span class="hljs-number">127</span>]})
<span class="hljs-keyword">echo</span> innerJoin(df1, df2, by = <span class="hljs-string">&quot;Class&quot;</span>)</code></pre>
<pre><samp>Dataframe with 3 columns and 5 rows:
       Idx     Class       Num       Ids
    dtype:    string       int       int
         0         A         1       125
         1         B         5       124
         2         C         3       127
         3         D         4       126
         4         E         6       123

</samp></pre>
<p>where we joined two data frames by the &quot;Class&quot; column, resulting in a data frame with
3 columns. The matching rows for the classes were put together aligning corresponding
&quot;Num&quot; and &quot;Ids&quot; values.</p>
<p>Of course joining two data frames is only a sensible option for a column containing
discrete data so that equal elements in that column for both input data frames can
be found.</p>
<p>This already covers the <em>majority</em> of the API of Datamancer. There are more procedures,
but the presented ones should be all that is needed in the vast majority of use cases.</p>
<p>Check out the <a href="https://scinim.github.io/Datamancer/datamancer.html">Datamancer documentation</a>
for a full picture and in particular for a better and more thorough introduction to the
formula syntax.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basics/common_datatypes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basics/basic_plotting.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basics/common_datatypes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basics/basic_plotting.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>







        <script src="../assets/js/clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../assets/js/highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../assets/js/book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
