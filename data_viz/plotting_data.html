<!DOCTYPE HTML>
<html lang="en-us" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using nimibook -->
        <meta charset="UTF-8">
        <title>Plotting data - SciNim Getting Started</title>

        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Tutorials for libraries in SciNim ecosystems">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
        <link rel="stylesheet" href="../assets/css/variables.css">
        <link rel="stylesheet" href="../assets/css/general.css">
        <link rel="stylesheet" href="../assets/css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../assets/FontAwesome/css/font-awesome.min.css">

        <!-- Highlight.js Stylesheets - I could use nimib native highlight but let's keep it for styling... -->
        <link rel="stylesheet" href="../assets/css/highlight.css">
        <link rel="stylesheet" href="../assets/css/tomorrow-night.css">
        <link rel="stylesheet" href="../assets/css/ayu-highlight.css">

        <!-- Custom theme stylesheets - why the "../"? -->


        
        
        <!-- plausible analytics (new in nimibook) -->
        <script defer data-domain="scinim.github.io/getting-started" src="https://plausible.io/js/plausible.js"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "..//assets";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                                <ol class="chapter">
                <li class="chapter-item expanded ">
                  <a href="../index.html" tabindex="0">
                    <strong aria-hidden="true">1.</strong> Introduction
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../overview/index.html" tabindex="0">
                    <strong aria-hidden="true">2.</strong> Ecosystem overview
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../basics/index.html" tabindex="0">
                    <strong aria-hidden="true">3.</strong> Basic topics
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../basics/common_datatypes.html" tabindex="0">
                    <strong aria-hidden="true">3.1.</strong> Common datatypes
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../basics/data_wrangling.html" tabindex="0">
                    <strong aria-hidden="true">3.2.</strong> Data wrangling with dataframes
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../basics/basic_plotting.html" tabindex="0">
                    <strong aria-hidden="true">3.3.</strong> Plotting
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../basics/units_basics.html" tabindex="0">
                    <strong aria-hidden="true">3.4.</strong> Units
                  </a></li>
                  </ol>
                  </li>
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/index.html" tabindex="0">
                    <strong aria-hidden="true">4.</strong> Numerical methods
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/curve_fitting.html" tabindex="0">
                    <strong aria-hidden="true">4.1.</strong> Curve fitting
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../numerical_methods/integration1d.html" tabindex="0">
                    <strong aria-hidden="true">4.2.</strong> Integration (1D)
                  </a></li>
                  </ol>
                  </li>
                <li class="chapter-item expanded ">
                  <a href="../data_viz/index.html" tabindex="0">
                    <strong aria-hidden="true">5.</strong> Data visualization
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../data_viz/plotting_data.html" class="active" tabindex="0">
                    <strong aria-hidden="true">5.1.</strong> Plotting data
                  </a></li>
                  </ol>
                  </li>
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/index.html" tabindex="0">
                    <strong aria-hidden="true">6.</strong> Interfacing with other language
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/nim_with_py.html" tabindex="0">
                    <strong aria-hidden="true">6.1.</strong> Nimpy - The Nim Python bridge
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/julia/basics.html" tabindex="0">
                    <strong aria-hidden="true">6.2.</strong> Nimjl - The Nim Julia bridge
                  </a></li>
                  <li>
                  <ol class="section">
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/julia/nimjl_conversions.html" tabindex="0">
                    <strong aria-hidden="true">6.2.1.</strong> Advanced types
                  </a></li>
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/julia/nimjl_arrays.html" tabindex="0">
                    <strong aria-hidden="true">6.2.2.</strong> Julia Arrays from Nim
                  </a></li>
                  </ol>
                  </li>
                <li class="chapter-item expanded ">
                  <a href="../external_language_integration/nim_with_R.html" tabindex="0">
                    <strong aria-hidden="true">6.3.</strong> Interfacing with R
                  </a></li>
                </ol>
<!-- I could use also an unescaped context value -->
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">SciNim Getting Started</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/SciNim/getting-started" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1>Plotting data using <a href="https://github.com/Vindaar/ggplotnim">ggplotnim</a></h1>
<p>In this tutorial we will introduce <code>ggplotnim</code>, a Nim plotting library heavily inspired
by the great R library <a href="https://ggplot2.tidyverse.org">ggplot2</a>.</p>
<p>This will be kept rather brief, but we will discuss the philosophy of the syntax, look
at a reasonably complex plotting example that we deconstruct and finish of by (hopefully)
coming to the conclusion that the ggplot-like syntax is rather elegant.</p>
<p>For this tutorial you should have read the data wrangling introduction to <code>Datamancer</code> or
know about data frames and have seen the <code>Datamancer</code> formula macro <code>f{}</code>.</p>
<h2>On philosophy and graphics</h2>
<p>Similar to most areas of life touched by more than a few people who seemingly all have
their own ideas about the right way to do things, plotting libraries come in different
shapes and forms. In terms of their output formats, choice of colors and style and
of most importance for us here: in terms of their API / the programming syntax used.</p>
<p>Most plotting libraries fall into a category that are either focused on object orientation
(your commands return some objects for you to modify to your needs) or a generally imperative
style (call this function <code>plotFoo</code> for plot style A, that function <code>plotBar</code> for style B,
etc.) and often some combination of these two.</p>
<p><code>ggplot2</code> and as a result <code>ggplotnim</code> follow a declarative style that builds up a plot
from a single command by combining multiple different layers as a chain of commands.</p>
<p>This is because <code>ggplot2</code> is an implementation of the so called &quot;grammar of graphics&quot;.
It's the NixOS of plotting libraries. Tell it what you want and it gets it done for you,
as long as you speak its language.</p>
<h2>A motivating example</h2>
<p>Let's now consider a somewhat complicated plotting example. Using that we will look at why
it is called a <em>grammar</em> of graphics.</p>
                        <pre><code class="nim hljs"><span class="hljs-comment">## ignore the dummy `df` here. This is to be able to compile the code (we throw away</span>
<span class="hljs-comment">## the `ggplot` result as we don't call `ggsave`)</span>
<span class="hljs-keyword">let</span> df = toDf({<span class="hljs-string">&quot;Energy&quot;</span> : @[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Counts&quot;</span> : @[<span class="hljs-number">2</span>], <span class="hljs-string">&quot;Type&quot;</span> : @[<span class="hljs-string">&quot;background&quot;</span>]})
<span class="hljs-keyword">discard</span> ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  geom_point(binPosition = <span class="hljs-string">&quot;center&quot;</span>) +
  geom_errorbar(data = df.filter(f{`<span class="hljs-keyword">Type</span>` == <span class="hljs-string">&quot;background&quot;</span>}),
                aes = aes(yMin = f{max(`<span class="hljs-type">Counts</span>` - <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>)}, yMax = f{`<span class="hljs-type">Counts</span>` + <span class="hljs-number">1.0</span>}),
                binPosition = <span class="hljs-string">&quot;center&quot;</span>) +
  xlab(<span class="hljs-string">&quot;Energy [keV]&quot;</span>) + ylab(<span class="hljs-string">&quot;#&quot;</span>) +
  ggtitle(<span class="hljs-string">&quot;A multi-layer plot of a histogram and scatter plot with error bars&quot;</span>)</code></pre>
                        <p>It may seem overwhelming. But it's actually simple and can be read from top to bottom.
In words all this says is:</p>
<p>&quot;Create a plot from the input data frame <code>df</code> using column 'Energy' for the x axis, 'Counts'
for the y axis and color the data (both outline <code>color</code> and fill color <code>fill</code>) based on the
discrete entries of column 'Type'. With it draw:</p>
<ul>
<li>a histogram without statistical computations (<code>stat = &quot;identity&quot;</code>, i.e. don't <em>compute</em> a histogram
but use the data as a continuous bar plot), draw them in identity position (where the data says,
no stacking of bars), add some alpha to the color and draw it as an outline.</li>
<li>a scatter plot in the center positions of each bin (<code>binPosition = &quot;center&quot;</code>), as the data
contains bin edges.</li>
<li>errorbars for all data of type 'background' (<code>data = df.filter(‚Ä¶)</code>), where the error bars range
from <code>yMin</code> to <code>yMax</code> for all points, also in center position.</li>
</ul>
<p>Finally, customize x (<code>xlab</code>) and y (<code>ylab</code>) labels and add a title (<code>ggtitle</code>).&quot;</p>
<p>The only thing we left out is the <code>ggsave</code> call, as we only have a dummy data frame here. We
will now walk through the basic building blocks of every plot and then look at the above as
an actual plot. After reading the next part looking at the plot above again should make it seem
less dense already.</p>
<h2>The 3 (or 4) basic building blocks of a &quot;ggplot&quot; plot</h2>
<p>There are 3 (in some respect 4) major pieces that make up the basic syntax of <em>every single</em>
plot created by <code>ggplot2</code> or <code>ggplotnim</code>. We will quickly go through these now. Keep
in mind that every option that might be automatically deduced can always be overridden.</p>
<h3>Input data</h3>
<p>The zeroth piece (hence maybe 4) of a ggplot plot is the input data. It <em>always</em> comes
in the form of a <code>DataFrame</code> that contains the data to be plotted (or at least the data
from which the thing to be plotted can be computed from, more on that later). If not
overridden manually the columns that are to be plotted define the labels for
the axes in the final plot.</p>
<p>In addition the library will determine automatically (based on column types &amp; heuristic
rules) whether each column to be plotted is continuous or discrete. Continuity and discreteness
are a major factor in the kinds of plots we may create (and how they are represented).</p>
<p>So for the next sections let's say we have some input data frame <code>df</code>.</p>
<h3>The <code>ggplot</code> procedure</h3>
<p>The first proper piece of <em>every</em> plot is a call to the <code>ggplot</code> procedure. It has a rather
simple signature (note: we drop 2 arguments here, as they are left over in the code for &quot;historical&quot;
reasons, namely <code>numX/YTicks</code>):</p>
<pre><code class="language-nim">proc ggplot*(data: DataFrame, aes: Aesthetics = aes(), ‚Ä¶): GgPlot =
</code></pre>
<p>The first argument is the aforementioned input <code>DataFrame</code>. With our data frame, we can
write down the first piece of every plot we will create:</p>
<pre><code class="language-nim">ggplot(df, ‚Ä¶)
</code></pre>
<p>Simple enough. This doesn't do anything interesting yet. That's what the <code>aes</code> is for.</p>
<h3><code>aes</code> - Aesthetics</h3>
<p>The <code>aes</code> argument of the <code>ggplot</code> procedure is the first deciding piece of our plotting
call. It will essentially determine <em>what</em> we wish to plot and to some extend <em>how</em> we
want to plot it.</p>
<p>&quot;Aesthetics&quot; are the name for the description of the &quot;aesthetic description&quot; about which
data to use for what visible purpose. This might sound abstract, but will become clear
in a few seconds.</p>
<p>For the simplest cases (a scatter or line plot, a histogram, ...) we simply hand a (or multiple)
column(s) to draw. Depending on whether a column contains discrete or continuous data decides
how the axis (or additional scale) will be laid out.</p>
<p>To construct such an <code>Aesthetic</code> argument the <code>aes</code> macro is used. While it is a macro it
behaves like a regular procedure and can take the following arguments:</p>
<ul>
<li><code>x</code></li>
<li><code>y</code></li>
<li><code>color</code></li>
<li><code>fill</code></li>
<li><code>shape</code></li>
<li><code>size</code></li>
<li><code>xmin</code></li>
<li><code>xmax</code></li>
<li><code>ymin</code></li>
<li><code>ymax</code></li>
<li><code>width</code></li>
<li><code>height</code></li>
<li><code>text</code></li>
<li><code>weight</code></li>
<li><code>yridges</code></li>
</ul>
<p>quite the list!</p>
<p>Taking a closer look at the kind of arguments gives us maybe an inkling of what it's all about.
The argument either maps to a physical axis in the plot (x, y), a &quot;style&quot;-like thing (color,
fill, shape, size) or some more &quot;descriptive&quot; thing (e.g. for sizes x/yMin/Max, width, height),
and finally some slightly &quot;special&quot; ones (text, weight, yridges).</p>
<p>What each of these mean for the final plot (again) depends on the data being discrete or continuous.</p>
<p>As an example:</p>
<ul>
<li>Discrete, each discrete value:
<ul>
<li>x and y: has one tick along x or y</li>
<li>color: has one color</li>
<li>shape: has one shape</li>
<li>size: has one size</li>
</ul>
</li>
<li>Continuous, each value:
<ul>
<li>x and y: map to a continuous range between min and max values</li>
<li>color and fill: has a color picked from a continuous color range</li>
<li>size:  has a size picked from a continuous range between smallest and largest size</li>
<li>shape: not supported, there are no &quot;continuous shapes&quot;</li>
</ul>
</li>
</ul>
<p>(for the other aesthetics also only either discrete or continuous make sense. For instance &quot;text&quot; is
always a discrete input, it's used to draw text onto a plot. yridges is to create a discrete ridgeline
plot, etc.)</p>
<p>How these are finally applied still depends on what comes later in the plotting syntax. But in principle
the mapping to more specific things to be drawn is natural. For a point plot the size determines the point
size and the color the point color. For a line it's line width and color and so on.</p>
<p>This part of the ggplot construction might be the most &quot;vague&quot; at first. But with it we can
now continue our construction. Assume our data frame <code>df</code> has columns &quot;Energy&quot; and &quot;Counts&quot; (continuous),
&quot;Type&quot; (discrete).</p>
<pre><code class="language-nim">ggplot(df, aes(&quot;Energy&quot;, &quot;Counts&quot;, fill = &quot;Type&quot;, color = &quot;Type&quot;))
</code></pre>
<p>In a sense this has described a coordinate system for our plot. From the continuous / discrete columns
we can determine the data ranges ranges / classes for each &quot;axis&quot;. Every aesthetic can
be considered an &quot;axis&quot; here. For example a scatter plot of <code>x</code> and <code>y</code> values that is also classified
by color using discrete column <code>A</code> and by shape using discrete column <code>B</code> is technically a 4
dimensional representation.</p>
<h4>Formulas as <code>aes</code> arguments</h4>
<p>If you paid close attention to the plot example above, you will have noticed that for <code>yMin</code> and <code>yMax</code>
we did not actually hand a column, but rather a <code>ggplotnim</code> <a href="https://scinim.github.io/getting-started/basics/data_wrangling.html">formula</a>. This is the main reason <code>aes</code> is a macro.</p>
<p>You can hand <em>any</em> formula that references local variables or column references, or simply assign
constant values (<code>aes(width = 5)</code> is perfectly valid). <code>ggplotnim</code> will compute the resulting values
for you automatically before plotting.</p>
<p>To summarize, you can use one of the following three things as values to <code>aes</code> arguments:</p>
<ul>
<li>a string literal referring to a column</li>
<li>a formula computing some constant value or some operation using data frame columns</li>
<li>a constant (non string) value that can be stored in a data frame</li>
</ul>
<p>For formulas and constant values the corresponding absolute value will be computed for each
data frame entry to be plotted.</p>
<h3><code>geoms</code> - Geometric shapes to fill a plot</h3>
<p>Input data and aesthetics of course are not enough to actually draw a plot. So far we have only
stated what part of the data to use and added a discrete classification by one column (fill
and color the &quot;Type&quot; column).</p>
<p>This is what all available <code>geom_*</code> procedures are for. They return <code>Geom</code> variant objects that mainly
just store their kind and possibly some specific information required to draw them.</p>
<p>The (currently) implemented geoms are as follows (with the required aesthetics listed):</p>
<ul>
<li><code>geom_point</code>: draw points for each <code>x</code>/<code>y</code></li>
<li><code>geom_line</code>: draw a line through all <code>x</code>/<code>y</code></li>
<li><code>geom_errorbar</code>: draw error bars from <code>xMin</code> to <code>xMax</code> or <code>yMin</code> to <code>yMax</code> at <code>x</code>/<code>y</code></li>
<li><code>geom_linerange</code>: draw lines from <code>xMin</code> to <code>xMax</code> or <code>yMin</code> to <code>yMax</code></li>
<li><code>geom_bar</code>: draw a <em>discrete</em> bar plot using the occurrences (default <code>stat = &quot;count&quot;</code>) of each
discrete value in <code>x</code> or the number of counts indicated in <code>y</code> (<code>stat = &quot;identity&quot;</code>)</li>
<li><code>geom_histogram</code>: draw a <em>continuous</em> bar plot computing a histogram from continuous variable <code>x</code>
(default <code>stat = &quot;bin&quot;</code>) or draw continuous bars starting at <code>x</code> and the number of entries
indicated in <code>y</code> (<code>stat = &quot;identity&quot;</code>).</li>
<li><code>geom_freqpoly</code>: same as <code>geom_histogram</code>, but connect bin centers by lines instead of drawing bars</li>
<li><code>geom_tile</code>: draw discrete tiles at <code>x</code>/<code>y</code> (default position bottom left) with width <code>width</code> and height
<code>height</code> each. Tiles don't need to touch.</li>
<li><code>geom_raster</code>: draw fully connected tiles at <code>x</code>/<code>y</code> of <code>width</code> and <code>height</code>. <code>width</code> and <code>height</code> must
be constant!</li>
<li><code>geom_text</code>: draw text at <code>x</code>/<code>y</code> containing <code>text</code> (the <code>text</code> aesthetic)</li>
</ul>
<p>Here we stated mainly the <em>typical</em> (or default) use cases. All geoms take all arguments. That means
you can also draw a histogram using points by applying the <code>stat = &quot;bin&quot;</code> argument. The difference
is just in the defaults! Or in case of a <code>geom_histogram</code> call you can indicate that the <code>binPosition</code>
should be <code>&quot;center&quot;</code> instead of the default <code>&quot;left&quot;</code> to have <code>x</code> indicate the bin centers.</p>
<p>The possibilities are almost endless. You can combine any geom with (almost) any option and
it <em>should just work</em> (few exceptions exist, e.g. <code>geom_raster</code> only draws fixed size tiles for performance).</p>
<p>One final thing to mention: the <code>geom_histogram</code> procedures <em>also</em> take <code>data</code> and <code>aes</code>
arguments. This means one can override the data or the aesthetics for a single geom!</p>
<h4>Applying geom layers to build the initial plot</h4>
<p>We now need to apply the input data and selection of columns to things we can actually draw.</p>
<p>This is where the layering structure of <code>ggplot</code> actually becomes apparent, because from here
we will list all kinds of <code>geoms</code> to draw. The order we list them directly determines
the order they are drawn in.</p>
<p>Step by step we will now add layer by layer and look at what happens with each to reproduce
the plot talked about in the beginning. For that purpose we will generate a data frame that we
will use in all following snippets. It will contain 3 columns:</p>
<ul>
<li>&quot;Energy&quot;: a column of twice 25 elements covering the range (0, 10) with 25 entries</li>
<li>&quot;Counts&quot;: a column of twice 25 random entries between 0 and 10. The first 25 elements
are drawn as floats (to get fractional values) and the second 25 entries will be random
integer numbers</li>
<li>&quot;Type&quot;: simply a column that designates the first 25 rows as &quot;background&quot; and the latter
25 as &quot;candidates&quot;</li>
</ul>
<p>Our construction in the following is a bit artificial of course.</p>
                        <pre><code class="nim hljs"><span class="hljs-keyword">import</span> ggplotnim, random, sequtils
randomize(<span class="hljs-number">42</span>)
<span class="hljs-keyword">let</span> df = toDf({ <span class="hljs-string">&quot;Energy&quot;</span> : cycle(linspace(<span class="hljs-number">0.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">25</span>).toRawSeq, <span class="hljs-number">2</span>),
                    <span class="hljs-string">&quot;Counts&quot;</span> : concat(toSeq(<span class="hljs-number">0</span> ..&lt; <span class="hljs-number">25</span>).mapIt(rand(<span class="hljs-number">10.0</span>)),
                                      toSeq(<span class="hljs-number">0</span> ..&lt; <span class="hljs-number">25</span>).mapIt(rand(<span class="hljs-number">10</span>).<span class="hljs-built_in">float</span>)),
                    <span class="hljs-string">&quot;Type&quot;</span> : concat(newSeqWith(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;background&quot;</span>),
                                    newSeqWith(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;candidates&quot;</span>)) })
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Input data frame: &quot;</span>
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Head(10): &quot;</span>, df.head(<span class="hljs-number">10</span>).pretty(<span class="hljs-number">10</span>)
<span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Tail(10): &quot;</span>, df.tail(<span class="hljs-number">10</span>).pretty(<span class="hljs-number">10</span>)</code></pre><pre class="nb-output"><samp>Input data frame: 
Head(10): DataFrame with 3 columns and 10 rows:
     Idx       Energy       Counts         Type
  dtype:        float        float       string
       0            0         7.11   background
       1       0.4167         4.38   background
       2       0.8333        1.241   background
       3         1.25        3.799   background
       4        1.667        7.506   background
       5        2.083        1.701   background
       6          2.5        4.399   background
       7        2.917        4.608   background
       8        3.333        2.304   background
       9         3.75        5.275   background

Tail(10): DataFrame with 3 columns and 10 rows:
     Idx       Energy       Counts         Type
  dtype:        float        float       string
       0         6.25            4   candidates
       1        6.667            2   candidates
       2        7.083            5   candidates
       3          7.5            1   candidates
       4        7.917            3   candidates
       5        8.333            3   candidates
       6         8.75            2   candidates
       7        9.167            6   candidates
       8        9.583            8   candidates
       9           10            0   candidates</samp></pre>
                        <p>What we want to achieve as a final plot is the following, where the explanations
are mainly due to the original motivation of where the plot example is taken from:</p>
<ul>
<li>a histogram for each &quot;Type&quot;, drawn with one color each and a bit transparent so they
are visible where they overlap. Let each bin content correspond to some data point
at that energy.</li>
<li>also plot the actual data points on top of the bins. For the &quot;background&quot; like data
we have fractional values as it's values are normalized to the &quot;candidates&quot; (simply
by scaling from some hypothetical time for background / time for candidate data).</li>
<li>For the background data we want error bars. They represent our uncertainty of the
background hypothesis.</li>
<li>the candidates are just counts we measured. They don't have inherent uncertainties
(from a frequentist perspective we have to repeat the experiment many times and <em>then</em>
we can write down some variance in our candidates)</li>
</ul>
<h4>Building layer 1 - <code>geom_histogram</code></h4>
<p>So, let's start with drawing a histogram of &quot;Energy&quot; and &quot;Counts&quot;:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>)) +
  geom_histogram() +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_0.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_0.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>So, uhm. This looks rather broken! Or at least not what we want. What's going on?
We're asking for a histogram! By default this means <code>ggplotnim</code> will <em>compute</em> the
histogram based on the <code>x</code> aesthetic. (Note: it should at least print a warning
message if a <code>y</code> aesthetic is given that user probably wants identity stats!).
Instead our data is <em>already</em> binned. We need the <code>stat = &quot;identity&quot;</code> option to
the <code>geom_histogram</code> call:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_1.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_1.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>This looks a bit better. At least we have something that sort of resembles our
input data! But what's that wide gray bar spanning the whole <code>x</code> range with a
height of roughly 3?</p>
<p>Our data frame covers the <code>x</code> range <em>twice</em>. Once for our &quot;background&quot;
dataset, indices 0 to 24, and then again for our &quot;candidates&quot; dataset,
indices 25 to 49. At the intersection from the first part (index 24)
our &quot;Energy&quot; column is <code>10.0</code>. From there it jumps back to <code>0.0</code> (index</p>
<ol start="25">
<li>in the next bin. This leads to a full bin that accidentally covers
the full range from 0 to 10 (with a &quot;negative&quot; bin width if we compute</li>
</ol>
<p>it bin to bin). Let's check that assumption by printing values between
index 24 and 26 from our data frame:</p>
                        <pre><code class="nim hljs"><span class="hljs-keyword">echo</span> df[<span class="hljs-number">24</span> .. <span class="hljs-number">26</span>]</code></pre><pre class="nb-output"><samp>DataFrame with 3 columns and 3 rows:
     Idx       Energy       Counts         Type
  dtype:        float        float       string
       0           10        8.151   background
       1            0            9   candidates
       2       0.4167            8   candidates</samp></pre>
                        <p>As we can see index 24 with a value of <code>2.746</code> is used for a bin with bin width 10.</p>
<p>To get closer to the plot we want, we will perform classification by a discrete
variable. Let's <code>color</code> by the &quot;Type&quot; column:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_2.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_2.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>Ohh, interesting. See how we have an automatic legend based on the
two classes found in column &quot;Type&quot;.</p>
<p>The entries seem a bit high right now. We only sampled up to a total of
10. And didn't we say we want to have classification by <code>color</code>? For bars
<code>color</code> refers to the <em>outline</em> of a bar. We need to add a <code>fill</code> to get the
bars into a fully colored object.</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_3.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_3.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>Aha! Apparently both classes are being <em>stacked</em> on top of one
another. This is the default behavior for classified histograms so
that all the data is visible. Without transparency we would hide data
otherwise.</p>
<p>To change this behavior to the one we want we will apply <code>position =&quot;identity&quot;</code>:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_4.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_4.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>This is already looking somewhat reasonable, barring the fact that we now
have the exact problem stacking is supposed to fix. One histogram overlaps
the other. We can solve that by applying 50% alpha channel:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_5.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_5.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>The plot we're seeing is quite pretty already. The only small
annoyance is that the outline is still sticking out between all bars,
which makes it more busy than it should be. Let's fix that by drawing
the histograms using <em>outlines</em> instead of individual bars:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_6.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_6.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>Nice, first layer done! This is the result we want to achieve for the <em>histogram</em> part
of our plot. As we can see, we've added <em>one</em> geom to the call chain. One layer.</p>
<h4>Building layer 2 - <code>geom_point</code></h4>
<p>Next up, let's plot some points for the data to better highlight where our actual
data lies (and to lay the foundation for our error bars). This is as simple as adding
a single <code>geom_point</code> call into the chain:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  geom_point() +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_7.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_7.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>But wait. Why are our points on the left side of each bar? Because we defined our
<code>Energy</code> column to contain <em>bin edges</em>. This is because different geoms use different
defaults for their arguments. A histogram with identity statistics essentially interprets
the <code>x</code> axis data as bin edges, whereas point plot of courses uses the <code>x</code> values as the
location where to draw the points.</p>
<p>However, the grammar of graphics allows us to change that as well. Let's tell <code>geom_point</code>
that the data points are <em>bin centers</em>:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  geom_point(binPosition = <span class="hljs-string">&quot;center&quot;</span>) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_8.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_8.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>Perfect, now our points are right where they belong. This concludes layer 2.</p>
<h4>Building layer 3 - <code>geom_errorbar</code></h4>
<p>This leaves us with a single, final layer. Those of the error bars.
Due to a bug present right now, we cannot call <code>geom_errorbar</code> without min / max
aesthetic args right now (which should in practice raise an exception or
draw nothing, because without limits error bars make no sense).</p>
<p>So, let's assume we want (arbitrary) error bars that are ¬± 1 at each
point. This can be achieved by assigning a formula to the <code>yMin</code> and
<code>yMax</code> aesthetic in which we describe this relationship. Start with <code>yMin</code>:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  geom_point(binPosition = <span class="hljs-string">&quot;center&quot;</span>) +
  geom_errorbar(aes = aes(yMin = f{`<span class="hljs-type">Counts</span>` - <span class="hljs-number">1.0</span>})) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_9.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_9.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>Looking closely, we see that the error bars in some bins go to
negative values! That's not acceptable for us. Error bars on counts
should stop at 0, because we cannot measure negative counts!</p>
<p>We do this by modifying the formula for <code>yMin</code> to simply take the maximum value
in each case between the computed difference and 0.</p>
<p>And in addition they are also drawn on the left side of each bin. Let's fix
both the range of the bar as well as its placement:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  geom_point(binPosition = <span class="hljs-string">&quot;center&quot;</span>) +
  geom_errorbar(binPosition = <span class="hljs-string">&quot;center&quot;</span>, aes = aes(yMin = f{max(`<span class="hljs-type">Counts</span>` - <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>)})) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_11.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_11.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>Much better. Of course we still only have error bars in the negative direction and lines
down to zero (<code>yMax</code> is unset, so default value 0). On to add positive bars then:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  geom_point(binPosition = <span class="hljs-string">&quot;center&quot;</span>) +
  geom_errorbar(binPosition = <span class="hljs-string">&quot;center&quot;</span>, aes = aes(yMin = f{max(`<span class="hljs-type">Counts</span>` - <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>)}, yMax = f{`<span class="hljs-type">Counts</span>` + <span class="hljs-number">1.0</span>})) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_12.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_12.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>Sweet! But wait, we still have error bars for the &quot;candidates&quot; dataset. This is where
the fact that individual geoms can receive their own data frame comes in. We'll simply
hand <code>geom_errorbar</code> the input data frame filtered to only &quot;background&quot; rows. This way
it will only have that data to plot and we should end up without error bars on the
&quot;candidates&quot; data:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  geom_point(binPosition = <span class="hljs-string">&quot;center&quot;</span>) +
  geom_errorbar(binPosition = <span class="hljs-string">&quot;center&quot;</span>, data = df.filter(f{`<span class="hljs-keyword">Type</span>` == <span class="hljs-string">&quot;background&quot;</span>}),
                aes = aes(yMin = f{max(`<span class="hljs-type">Counts</span>` - <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>)}, yMax = f{`<span class="hljs-type">Counts</span>` + <span class="hljs-number">1.0</span>})) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram_13.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram_13.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>Perfect! Let's round it off by modifying the <code>x</code> and <code>y</code> labels and add a nice
title on top:</p>
                        <pre><code class="nim hljs">ggplot(df, aes(<span class="hljs-string">&quot;Energy&quot;</span>, <span class="hljs-string">&quot;Counts&quot;</span>, color = <span class="hljs-string">&quot;Type&quot;</span>, fill = <span class="hljs-string">&quot;Type&quot;</span>)) +
  geom_histogram(stat = <span class="hljs-string">&quot;identity&quot;</span>, position = <span class="hljs-string">&quot;identity&quot;</span>, alpha = <span class="hljs-number">0.5</span>, hdKind = hdOutline) +
  geom_point(binPosition = <span class="hljs-string">&quot;center&quot;</span>) +
  geom_errorbar(binPosition = <span class="hljs-string">&quot;center&quot;</span>, data = df.filter(f{`<span class="hljs-keyword">Type</span>` == <span class="hljs-string">&quot;background&quot;</span>}),
                aes = aes(yMin = f{max(`<span class="hljs-type">Counts</span>` - <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>)}, yMax = f{`<span class="hljs-type">Counts</span>` + <span class="hljs-number">1.0</span>})) +
  xlab(<span class="hljs-string">&quot;Energy [keV]&quot;</span>) + ylab(<span class="hljs-string">&quot;#&quot;</span>) +
  ggtitle(<span class="hljs-string">&quot;A multi-layer plot of a histogram and scatter plot with error bars&quot;</span>) +
  ggsave(<span class="hljs-string">&quot;images/multi_layer_histogram.png&quot;</span>)</code></pre>
                        <figure>
<img src="../images/multi_layer_histogram.png" alt="">
<figcaption></figcaption>
</figure>
                        <p>And here we are. We've rebuilt the whole plot from the beginning. Now you should have a
good idea of why this plot looks the way it does.</p>
<p>The great thing is that this is the whole workflow of ggplot. You won't have to search
through weird N levels deep inheritances of objects (looking at you, matplotlib!) to
figure out how to do this or that. Every other feature <code>ggplotnim</code> provides is
also handled in the same way. We just replace a few geoms or arguments or maybe add
another command. That's all there is to the grammar of graphics. Simple, but powerful.</p>
<p>With an understanding of the grammar of graphics, one can then essentially plot everything
that can be mapped to geometric objects and data, even for example
<a href="https://github.com/Vindaar/ggplotnim/blob/master/recipes.org#fun-with-elements">a periodic table</a>.</p>
<h2>A gallery of plotting examples</h2>
<p>For a large variety of actual plotting example snippets, check out the <code>ggplotnim</code> recipe section here:</p>
<p><a href="https://github.com/Vindaar/ggplotnim/blob/master/recipes.org">Recipes</a></p>
<p>Thanks for reading! :)</p>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../data_viz/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../external_language_integration/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../data_viz/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../external_language_integration/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>







        <script src="../assets/js/clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../assets/js/highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../assets/js/book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
